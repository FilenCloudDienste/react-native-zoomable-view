{"version":3,"file":"index.js","sources":["../src/ReactNativeZoomableView.tsx","../src/ReactNativeZoomableViewWithGestures.tsx"],"sourcesContent":["import { ReactNativeZoomableViewProps, ReactNativeZoomableViewState, ZoomableViewEvent } from '@dudigital/react-native-zoomable-view';\nimport React, { Component } from 'react';\nimport {\n    View,\n    StyleSheet,\n    PanResponder,\n} from 'react-native';\n\nconst initialState = {\n    lastZoomLevel: 1,\n    offsetX: 0,\n    offsetY: 0,\n    lastX: 0,\n    lastY: 0,\n    lastMovePinch: false,\n    originalWidth: null,\n    originalHeight: null,\n};\n\nclass ReactNativeZoomableView extends Component<ReactNativeZoomableViewProps, ReactNativeZoomableViewState> {\n    gestureHandlers: any;\n    distance: number;\n    isDistanceSet: boolean;\n    lastPressHolder: number;\n    gestureType: 'pinch' | 'shift' | 'null';\n    contextState = {\n        distanceLeft: 0,\n        distanceRight: 0,\n        distanceTop: 0,\n        distanceBottom: 0,\n    };\n\n    static defaultProps = {\n        zoomEnabled: true,\n        initialZoom: 1,\n        initialOffsetX: 0,\n        initialOffsetY: 0,\n        maxZoom: 1.5,\n        minZoom: 0.5,\n        pinchToZoomInSensitivity: 3,\n        pinchToZoomOutSensitivity: 1,\n        zoomCenteringLevelDistance: 0.5,\n        movementSensibility: 1.9,\n        doubleTapDelay: 300,\n        bindToBorders: true,\n        zoomStep: 0.5,\n        onLongPress: null,\n        longPressDuration: 700,\n        captureEvent: false,\n    };\n\n    constructor(props) {\n        super(props);\n\n        this.gestureHandlers = PanResponder.create({\n            onStartShouldSetPanResponder: this._handleStartShouldSetPanResponder,\n            onMoveShouldSetPanResponder: this._handleMoveShouldSetPanResponder,\n            onPanResponderGrant: this._handlePanResponderGrant,\n            onPanResponderMove: this._handlePanResponderMove,\n            onPanResponderRelease: this._handlePanResponderEnd,\n            onPanResponderTerminationRequest: evt => false,\n            onShouldBlockNativeResponder: evt => false,\n        });\n\n        this.state = {\n            ...initialState,\n            zoomLevel: props.initialZoom,\n            lastZoomLevel: props.initialZoom || initialState.lastZoomLevel,\n            offsetX: props.initialOffsetX,\n            offsetY: props.initialOffsetY,\n        };\n\n        this.distance = 150;\n        this.isDistanceSet = true;\n\n        this.gestureType = null;\n\n        this.contextState = {\n            distanceLeft: 0,\n            distanceRight: 0,\n            distanceTop: 0,\n            distanceBottom: 0,\n        };\n    }\n\n    componentDidUpdate(prevProps) {\n        const { zoomEnabled, initialZoom } = this.props;\n        if (prevProps.zoomEnabled && !zoomEnabled) {\n            this.setState({\n                zoomLevel: initialZoom,\n                ...initialState\n            });\n        }\n    }\n\n    /**\n     * Last press time (used to evaluate whether user double tapped)\n     * @type {number}\n     */\n    longPressTimeout = null;\n\n    /**\n     * Current position of zoom center\n     * @type { x: number, y: number }\n     */\n    pinchZoomPosition = null;\n\n    /**\n     * Returns additional information about components current state for external event hooks\n     *\n     * @returns {{}}\n     * @private\n     */\n    _getZoomableViewEventObject(overwriteObj = {}): ZoomableViewEvent {\n        return {\n            ...this.state,\n            ...this.contextState,\n            ...overwriteObj,\n        } as ZoomableViewEvent;\n    }\n\n    /**\n     * Get the original box dimensions and save them for later use.\n     * (They will be used to calculate boxBorders)\n     *\n     * @param layoutEvent\n     * @private\n     */\n    _getBoxDimensions = (layoutEvent) => {\n        const { x, y, height, width } = layoutEvent.nativeEvent.layout;\n\n        this.setState({\n            originalWidth: width,\n            originalHeight: height,\n        });\n    };\n\n    /**\n     * Handles the start of touch events and checks for taps\n     *\n     * @param e\n     * @param gestureState\n     * @returns {boolean}\n     *\n     * @private\n     */\n    _handleStartShouldSetPanResponder = (e, gestureState) => {\n        this._doubleTapCheck(e, gestureState);\n\n        if (this.props.onStartShouldSetPanResponder) {\n            this.props.onStartShouldSetPanResponder(e, gestureState, this._getZoomableViewEventObject(), false);\n        }\n\n        return this.props.captureEvent;\n    };\n\n    /**\n     * Checks if the movement responder should be triggered\n     *\n     * @param e\n     * @param gestureState\n     * @returns {Boolean|boolean}\n     */\n    _handleMoveShouldSetPanResponder = (e, gestureState) => {\n        let baseComponentResult =\n            this.props.zoomEnabled &&\n            (Math.abs(gestureState.dx) > 2 ||\n                Math.abs(gestureState.dy) > 2 ||\n                gestureState.numberActiveTouches === 2);\n\n        if (this.props.onMoveShouldSetPanResponder) {\n            baseComponentResult = this.props.onMoveShouldSetPanResponder(\n                e,\n                gestureState,\n                this._getZoomableViewEventObject(),\n                baseComponentResult\n            );\n        }\n\n        return baseComponentResult;\n    };\n\n\n    /**\n     * Calculates pinch distance\n     *\n     * @param e\n     * @param gestureState\n     * @private\n     */\n    _handlePanResponderGrant = (e, gestureState) => {\n        this.isDistanceSet = false;\n\n        if (gestureState.numberActiveTouches === 2) {\n            let dx = Math.abs(e.nativeEvent.touches[0].pageX - e.nativeEvent.touches[1].pageX);\n            let dy = Math.abs(e.nativeEvent.touches[0].pageY - e.nativeEvent.touches[1].pageY);\n\n            let distant = Math.sqrt(dx * dx + dy * dy);\n            this.distance = distant;\n            this.isDistanceSet = true;\n        }\n\n        if (this.props.onLongPress) {\n            this.longPressTimeout = setTimeout(() => {\n                if (this.props.onLongPress) {\n                    this.props.onLongPress(e, gestureState, this._getZoomableViewEventObject());\n                    this.longPressTimeout = null;\n                }\n            }, this.props.longPressDuration);\n        }\n\n        if (this.props.onPanResponderGrant) {\n            this.props.onPanResponderGrant(e, gestureState, this._getZoomableViewEventObject());\n        }\n    };\n\n    /**\n     * Handles the end of touch events\n     *\n     * @param e\n     * @param gestureState\n     *\n     * @private\n     */\n    _handlePanResponderEnd = (e, gestureState) => {\n        this.setState({\n            lastX: this.state.offsetX,\n            lastY: this.state.offsetY,\n            lastZoomLevel: this.state.zoomLevel,\n        });\n\n        if (this.longPressTimeout) {\n            clearTimeout(this.longPressTimeout);\n            this.longPressTimeout = null;\n        }\n\n        if (this.props.onPanResponderEnd) {\n            this.props.onPanResponderEnd(e, gestureState, this._getZoomableViewEventObject());\n        }\n\n        if (this.gestureType === 'pinch') {\n            this.pinchZoomPosition = null;\n            if (this.props.onZoomEnd) {\n                this.props.onZoomEnd(e, gestureState, this._getZoomableViewEventObject());\n            }\n        } else if (this.gestureType === 'shift') {\n            if (this.props.onShiftingEnd) {\n                this.props.onShiftingEnd(e, gestureState, this._getZoomableViewEventObject());\n            }\n        }\n\n        this.gestureType = null;\n    };\n\n    /**\n     * Takes a single offset value and calculates the correct offset value within our view to make\n     *\n     * @param {'x'|'y'} axis\n     * @param offsetValue\n     * @param containerSize\n     * @param elementSize\n     * @param zoomLevel\n     *\n     * @returns {number}\n     */\n    _getBoundOffsetValue(axis: 'x' | 'y', offsetValue: number, containerSize: number, elementSize: number, zoomLevel: number) {\n        const zoomLevelOffsetValue = (zoomLevel * offsetValue);\n\n        const containerToScaledElementRatioSub = 1 - (containerSize / elementSize);\n        const halfLengthPlusScaledHalf = 0.5 + (0.5 / zoomLevel);\n        const startBorder = containerSize * containerToScaledElementRatioSub * halfLengthPlusScaledHalf;\n        const endBorder = (containerSize + startBorder - containerSize) * -1;\n\n        // calculate distance to start and end borders\n        const distanceToStart = (offsetValue - startBorder);\n        const distanceToEnd = (offsetValue + startBorder) * -1;\n\n        // set context for callback events\n        this._setContextStateDistances(axis, distanceToStart, distanceToEnd);\n\n        // if both sides (before and after the element) have a positive distance\n        // => (our zoomed content is smaller than the frame)\n        // => so center it\n        if (containerSize > elementSize) {\n            return ((containerSize / 2) - (elementSize / 2) / zoomLevel);\n        }\n\n        // if everything above failed\n        // => (one side is outside of the borders)\n        // => find out which one it is and make sure it is 0\n        if (distanceToStart > 0) {\n            return startBorder;\n        }\n\n        // if there is distance to the end border\n        // => (it is outside of the box)\n        // => adjust offset to make sure it stays within\n        if (distanceToEnd > 0) {\n            return endBorder;\n        }\n\n        // if everything above failed\n        // => (everything is within borders)\n        // => just return the original offset value\n        return offsetValue;\n    }\n\n    /**\n     * Sets the distance to borders for callback events\n     *\n     * @param axis\n     * @param distanceToStart\n     * @param distanceToEnd\n     * @private\n     */\n    _setContextStateDistances(axis: 'x' | 'y', distanceToStart: number, distanceToEnd: number) {\n        if (axis === 'x') {\n            this.contextState.distanceLeft = distanceToStart;\n            this.contextState.distanceRight = distanceToEnd;\n            return;\n        }\n\n        this.contextState.distanceTop = distanceToStart;\n        this.contextState.distanceBottom = distanceToEnd;\n    }\n\n    /**\n     * Takes a change object (that is going to be used in setState) and makes sure offsetX and\n     * offsetY are within our view borders. If that is not the case, they will be corrected.\n     *\n     * @param changeObj the object that is going to be modified.\n     *    Needs to contain at least the following elements:\n     *    {\n     *      zoomLevel: numeric,\n     *      offsetX: numeric,\n     *      offsetY: numeric,\n     *    }\n     * @private\n     */\n    _bindOffsetValuesToBorders(changeObj, bindToBorders = null) {\n        // if bindToBorders is disabled -> nothing do here\n        if (bindToBorders === false ||\n            (bindToBorders === null && !this.props.bindToBorders)) {\n            return changeObj;\n        }\n\n        const { originalWidth, originalHeight } = this.state;\n\n        const currentElementWidth = originalWidth * changeObj.zoomLevel;\n        const currentElementHeight = originalHeight * changeObj.zoomLevel;\n\n        // make sure that view doesn't go out of borders\n        const offsetXBound = this._getBoundOffsetValue('x', changeObj.offsetX, originalWidth, currentElementWidth, changeObj.zoomLevel);\n        changeObj.offsetX = offsetXBound;\n\n        const offsetYBound = this._getBoundOffsetValue('y', changeObj.offsetY, originalHeight, currentElementHeight, changeObj.zoomLevel);\n        changeObj.offsetY = offsetYBound;\n\n        return changeObj;\n    }\n\n    /**\n     * Handles the acutal movement of our pan responder\n     *\n     * @param e\n     * @param gestureState\n     *\n     * @private\n     */\n    _handlePanResponderMove = (e, gestureState) => {\n        if (this.props.onPanResponderMove) {\n            if (this.props.onPanResponderMove(e, gestureState, this._getZoomableViewEventObject())) {\n                return false;\n            }\n        }\n\n        if (gestureState.numberActiveTouches === 2) {\n            if (this.longPressTimeout) {\n                clearTimeout(this.longPressTimeout);\n                this.longPressTimeout = null;\n            }\n\n            if (!this.isDistanceSet) {\n                this._handlePanResponderGrant(e, gestureState);\n            }\n\n            this.gestureType = 'pinch';\n            this._handlePinching(e, gestureState);\n        }\n        else if (gestureState.numberActiveTouches === 1) {\n            if (\n                this.longPressTimeout &&\n                (Math.abs(gestureState.dx) > 5 || Math.abs(gestureState.dy) > 5)\n            ) {\n                clearTimeout(this.longPressTimeout);\n                this.longPressTimeout = null;\n            }\n\n            if (this.gestureType !== 'pinch') {\n                this.gestureType = 'shift';\n            }\n            this._handleMovement(e, gestureState);\n        }\n    };\n\n    /**\n     * Handles the pinch movement and zooming\n     *\n     * @param e\n     * @param gestureState\n     *\n     * @private\n     */\n    _handlePinching = (e, gestureState) => {\n        const { maxZoom, minZoom, zoomCenteringLevelDistance, pinchToZoomInSensitivity, pinchToZoomOutSensitivity } = this.props;\n\n        let dx = Math.abs(e.nativeEvent.touches[0].pageX - e.nativeEvent.touches[1].pageX);\n        let dy = Math.abs(e.nativeEvent.touches[0].pageY - e.nativeEvent.touches[1].pageY);\n        let distant = Math.sqrt(dx * dx + dy * dy);\n\n        if (this.props.onZoomBefore) {\n            if (this.props.onZoomBefore(e, gestureState, this._getZoomableViewEventObject())) {\n                return false;\n            }\n        }\n\n        // define the new zoom level and take zoom level sensitivity into consideration\n        const zoomChangeFromStartOfPinch = (distant / this.distance);\n        const pinchToZoomSensitivity = (zoomChangeFromStartOfPinch < 1) ? pinchToZoomOutSensitivity : pinchToZoomInSensitivity;\n        let zoomLevel = ((zoomChangeFromStartOfPinch * this.state.lastZoomLevel) + this.state.lastZoomLevel * pinchToZoomSensitivity) / (pinchToZoomSensitivity + 1);\n\n        // make sure max and min zoom levels are respected\n        if (maxZoom !== null && zoomLevel > maxZoom) {\n            zoomLevel = maxZoom;\n        }\n\n        if (zoomLevel < minZoom) {\n            zoomLevel = minZoom;\n        }\n\n        // only use the first position we get by pinching, or the screen will \"wobble\" during zoom action\n        if (this.pinchZoomPosition === null) {\n            const pinchToZoomCenterX = Math.min(e.nativeEvent.touches[0].pageX, e.nativeEvent.touches[1].pageX) + (dx / 2);\n            const pinchToZoomCenterY = Math.min(e.nativeEvent.touches[0].pageY, e.nativeEvent.touches[1].pageY) + (dy / 2);\n\n            this.pinchZoomPosition = this._getOffsetAdjustedPosition(pinchToZoomCenterX, pinchToZoomCenterY);\n        }\n\n        // make sure we shift the layer slowly during our zoom movement\n        const zoomStage = Math.abs(zoomLevel - this.state.lastZoomLevel) / zoomCenteringLevelDistance;\n\n        const ratioOffsetX = this.state.lastX + zoomStage * this.pinchZoomPosition.x;\n        const ratioOffsetY = this.state.lastY + zoomStage * this.pinchZoomPosition.y;\n\n        // define the changeObject and make sure the offset values are bound to view\n        const changeStateObj = this._bindOffsetValuesToBorders({\n            zoomLevel,\n            lastMovePinch: true,\n            offsetX: ratioOffsetX,\n            offsetY: ratioOffsetY,\n        }, null);\n\n        this.setState(changeStateObj, () => {\n            if (this.props.onZoomAfter) {\n                this.props.onZoomAfter(e, gestureState, this._getZoomableViewEventObject());\n            }\n        });\n    };\n\n    /**\n     * Handles movement by tap and move\n     *\n     * @param e\n     * @param gestureState\n     *\n     * @private\n     */\n    _handleMovement = (e, gestureState) => {\n        const { movementSensibility } = this.props;\n\n        // make sure not to accidentally move after pinch to zoom\n        if (this.pinchZoomPosition) {\n            return;\n        }\n\n        let offsetX = this.state.lastX + gestureState.dx / this.state.zoomLevel / movementSensibility;\n        let offsetY = this.state.lastY + gestureState.dy / this.state.zoomLevel / movementSensibility;\n\n        this._setNewOffsetPosition(offsetX, offsetY);\n    };\n\n    /**\n     * Set the state to offset moved\n     * \n     * @param {number} newOffsetX \n     * @param {number} newOffsetY \n     * @param {bool} bindToBorders \n     * @param {bool} updateLastCoords should the last coordinates be updated as well?\n     * @param {() => void)} callbk\n     * @returns \n     */\n    _setNewOffsetPosition = (newOffsetX: number, newOffsetY: number, bindToBorders = true, updateLastCoords = false, callbk = null) => {\n        const { onShiftingBefore, onShiftingAfter } = this.props;\n\n        if (onShiftingBefore) {\n            if (onShiftingBefore(null, null, this._getZoomableViewEventObject())) {\n                return false;\n            }\n        }\n\n        const changeStateObj = this._bindOffsetValuesToBorders({\n            lastMovePinch: false,\n            zoomLevel: this.state.zoomLevel,\n            offsetX: newOffsetX,\n            offsetY: newOffsetY,\n        }, bindToBorders);\n\n        // if we want to update last coords as well -> do that\n        if (updateLastCoords) {\n            changeStateObj.lastX = changeStateObj.offsetX;\n            changeStateObj.lastY = changeStateObj.offsetY;\n        }\n\n        this.setState(changeStateObj, () => {\n            if (callbk) {\n                callbk();\n            }\n\n            if (onShiftingAfter) {\n                if (onShiftingAfter(null, null, this._getZoomableViewEventObject())) {\n                    return false;\n                }\n            }\n        });\n    }\n\n    /**\n     * Wraps the check for double tap\n     *\n     * @param e\n     * @param gestureState\n     *\n     * @private\n     */\n    _doubleTapCheck = (e, gestureState) => {\n        const now = new Date().getTime();\n\n        if (this.lastPressHolder && (now - this.lastPressHolder) < this.props.doubleTapDelay) {\n            delete this.lastPressHolder;\n            this._handleDoubleTap(e, gestureState);\n        } else {\n            this.lastPressHolder = now;\n        }\n    }\n\n    /**\n     * Handles the double tap event\n     *\n     * @param event\n     * @param gestureState\n     *\n     * @private\n     */\n    _handleDoubleTap(e, gestureState) {\n        const { onDoubleTapBefore, onDoubleTapAfter, doubleTapZoomToCenter } = this.props;\n\n        // ignore more than 2 touches\n        if (gestureState.numberActiveTouches > 1 || !this.props.zoomEnabled) {\n            return;\n        }\n\n        if (onDoubleTapBefore) {\n            onDoubleTapBefore(e, gestureState, this._getZoomableViewEventObject());\n        }\n\n        const nextZoomStep = this._getNextZoomStep();\n\n        // define new zoom position coordinates\n        const zoomPositionCoordinates = {\n            x: e.nativeEvent.locationX,\n            y: e.nativeEvent.locationY,\n        };\n\n        // if doubleTapZoomToCenter enabled -> always zoom to center instead\n        if (doubleTapZoomToCenter) {\n            zoomPositionCoordinates.x = 0;\n            zoomPositionCoordinates.y = 0;\n        }\n\n        this._zoomToLocation(\n            zoomPositionCoordinates.x,\n            zoomPositionCoordinates.y,\n            nextZoomStep,\n            true,\n            () => {\n                if (onDoubleTapAfter) {\n                    onDoubleTapAfter(e, gestureState, this._getZoomableViewEventObject({\n                        zoomLevel: nextZoomStep,\n                    }));\n                }\n            }\n        );\n\n    }\n\n\n    /**\n     * Returns the next zoom step based on current step and zoomStep property.\n     * If we are zoomed all the way in -> return to initialzoom\n     *\n     * @returns {*}\n     */\n    _getNextZoomStep() {\n        const { zoomStep, maxZoom, initialZoom } = this.props;\n        const { zoomLevel } = this.state;\n\n        if (zoomLevel === maxZoom) {\n            return initialZoom;\n        }\n\n        let nextZoomStep = zoomLevel + (zoomLevel * zoomStep);\n        if (maxZoom !== null && nextZoomStep > maxZoom) {\n            return maxZoom;\n        }\n\n        return nextZoomStep;\n    }\n\n    /**\n     * Converts touch events x and y coordinates into the context of our element center\n     *\n     * @param x\n     * @param y\n     * @returns {{x: number, y: number}}\n     *\n     * @private\n     */\n    _getOffsetAdjustedPosition(x: number, y: number) {\n        const { originalWidth, originalHeight } = this.state;\n\n        if (x === 0 && y === 0) {\n            return {\n                x: 0,\n                y: 0,\n            }\n        }\n\n        const returnObj = {\n            x: (-x + (originalWidth / 2)),\n            y: (-y + (originalHeight / 2)),\n        };\n\n        return returnObj;\n    }\n\n    /**\n     * Zooms to a specific location in our view\n     *\n     * @param x\n     * @param y\n     * @param newZoomLevel\n     * @param bindToBorders\n     * @param callbk\n     *\n     * @private\n     */\n    _zoomToLocation(x: number, y: number, newZoomLevel: number, bindToBorders = true, callbk = null) {\n        const offsetAdjustedPosition = this._getOffsetAdjustedPosition(x, y);\n\n        if (this.props.onZoomBefore) {\n            this.props.onZoomBefore(null, null, this._getZoomableViewEventObject());\n        }\n\n        // define the changeObject and make sure the offset values are bound to view\n        const changeStateObj = this._bindOffsetValuesToBorders({\n            zoomLevel: newZoomLevel,\n            offsetX: offsetAdjustedPosition.x,\n            offsetY: offsetAdjustedPosition.y,\n            lastZoomLevel: newZoomLevel,\n            lastX: offsetAdjustedPosition.x,\n            lastY: offsetAdjustedPosition.y,\n        }, bindToBorders);\n\n        this.setState(changeStateObj, () => {\n            if (callbk) {\n                callbk();\n            }\n\n            if (this.props.onZoomAfter) {\n                this.props.onZoomAfter(null, null, this._getZoomableViewEventObject());\n            }\n        });\n    }\n\n    /**\n     * Zooms to a specificied zoom level.\n     * Returns a promise if everything was updated and a boolean, whether it could be updated or if it exceeded the min/max zoom limits.\n     * \n     * @param {number} newZoomLevel \n     * @param {bool} bindToBorders \n     * \n     * @return {Promise<bool>}\n     */\n    zoomTo(newZoomLevel: number, bindToBorders = true): Promise<boolean> {\n        return new Promise((resolve) => {\n            // if we would go out of our min/max limits -> abort\n            if (newZoomLevel >= this.props.maxZoom\n                || newZoomLevel <= this.props.minZoom) {\n                resolve(false);\n                return;\n            }\n\n            this._zoomToLocation(0, 0, newZoomLevel, bindToBorders, () => {\n                resolve(true);\n            })\n        });\n    }\n\n    /**\n     * Zooms in or out by a specificied change level\n     * Use a positive number for `zoomLevelChange` to zoom in\n     * Use a negative number for `zoomLevelChange` to zoom out\n     * \n     * Returns a promise if everything was updated and a boolean, whether it could be updated or if it exceeded the min/max zoom limits.\n     * \n     * @param {number} newZoomLevel \n     * @param {bool} bindToBorders \n     * \n     * @return {Promise<bool>}\n     */\n    zoomBy(zoomLevelChange: number = null, bindToBorders = true): Promise<boolean> {\n        // if no zoom level Change given -> just use zoom step\n        if (!zoomLevelChange) {\n            zoomLevelChange = this.props.zoomStep;\n        }\n\n        return this.zoomTo(this.state.zoomLevel + zoomLevelChange, bindToBorders);\n    }\n\n    /**\n     * Moves the zoomed view to a specified position\n     * Returns a promise when finished\n     * \n     * @param {number} newOffsetX the new position we want to move it to (x-axis)\n     * @param {number} newOffsetY the new position we want to move it to (y-axis)\n     * @param {bool} bindToBorders \n     * \n     * @return {Promise<bool>}\n     */\n    moveTo(newOffsetX: number, newOffsetY: number, bindToBorders = true): Promise<void> {\n        const { zoomLevel, originalWidth, originalHeight } = this.state;\n\n        let offsetX = (newOffsetX - (originalWidth / 2)) / zoomLevel;\n        let offsetY = (newOffsetY - (originalHeight / 2)) / zoomLevel;\n\n        return new Promise((resolve) => {\n            this._setNewOffsetPosition(-offsetX, -offsetY, bindToBorders, true, () => {\n                resolve();\n            });\n        });\n    }\n\n    /**\n     * Moves the zoomed view by a certain amount.\n     * \n     * Returns a promise when finished\n     * \n     * @param {number} offsetChangeX the amount we want to move the offset by (x-axis)\n     * @param {number} offsetChangeXY the amount we want to move the offset by (y-axis)\n     * @param {bool} bindToBorders \n     * \n     * @return {Promise<bool>}\n     */\n    moveBy(offsetChangeX: number, offsetChangeY: number, bindToBorders = true): Promise<void> {\n        const { zoomLevel, lastX, lastY } = this.state;\n\n        let offsetX = lastX - offsetChangeX / zoomLevel;\n        let offsetY = lastY - offsetChangeY / zoomLevel;\n\n        return new Promise((resolve) => {\n            this._setNewOffsetPosition(offsetX, offsetY, bindToBorders, true, () => {\n                resolve();\n            });\n        });\n    }\n\n    render() {\n        return (\n            <View\n                style={styles.container}\n                {...this.gestureHandlers.panHandlers}\n                onLayout={this._getBoxDimensions}\n            >\n                <View\n                    style={[styles.wrapper, this.props.style, {\n                        transform: [\n                            { scale: this.state.zoomLevel },\n                            { scale: this.state.zoomLevel },\n                            { translateX: this.state.offsetX },\n                            { translateY: this.state.offsetY },\n                        ],\n                    }]}\n                >\n                    {this.props.children}\n                </View>\n            </View>\n        );\n    }\n}\n/* \nTODO: delete them if not needed anymore\n\nReactNativeZoomableView.propTypes = {\n    ...View.propTypes,\n    zoomEnabled: PropTypes.bool,\n    initialZoom: PropTypes.number,\n    initialOffsetX: PropTypes.number,\n    initialOffsetY: PropTypes.number,\n    maxZoom: PropTypes.number,\n    minZoom: PropTypes.number,\n    pinchToZoomInSensitivity: PropTypes.number, // the level of resistance (sensitivity) to zoom in (0 - 10) - higher is less sensitive - default: 3\n    pinchToZoomOutSensitivity: PropTypes.number, // the level of resistance (sensitivity) to zoom out (0 - 10) - higher is less sensitive default: 1\n    zoomCenteringLevelDistance: PropTypes.number, // the (zoom level - 0 - maxZoom) distance for pinch to zoom actions until they are shifted on new pinch to zoom center - higher means it centeres slower - default 0.5\n    movementSensibility: PropTypes.number, // how resistant should shifting the view around be? (0.5 - 5) - higher is less sensitive - default: 1.9\n    doubleTapDelay: PropTypes.number, // how much delay will still be recognized as double press\n    bindToBorders: PropTypes.bool, // makes sure that the object stays within box borders\n    zoomStep: PropTypes.number, // how much zoom should be applied on double tap\n    onZoomBefore: PropTypes.func, // triggered before pinch movement\n    onZoomAfter: PropTypes.func, // triggered after pinch movement\n    onZoomEnd: PropTypes.func, // triggered after pinch movement ended\n    onDoubleTapBefore: PropTypes.func,\n    onDoubleTapAfter: PropTypes.func,\n    onShiftingBefore: PropTypes.func, // triggered before shift movement\n    onShiftingAfter: PropTypes.func, // triggered after shift movement\n    onShiftingEnd: PropTypes.func, // triggered after shift movement ended\n    onStartShouldSetPanResponder: PropTypes.func,\n    onMoveShouldSetPanResponder: PropTypes.func,\n    onPanResponderGrant: PropTypes.func,\n    onPanResponderEnd: PropTypes.func,\n    onPanResponderMove: PropTypes.func,\n    onLongPress: PropTypes.func,\n    longPressDuration: PropTypes.number\n};\n\nReactNativeZoomableView.defaultProps = {\n    zoomEnabled: true,\n    initialZoom: 1,\n    initialOffsetX: 0,\n    initialOffsetY: 0,\n    maxZoom: 1.5,\n    minZoom: 0.5,\n    pinchToZoomInSensitivity: 3,\n    pinchToZoomOutSensitivity: 1,\n    zoomCenteringLevelDistance: 0.5,\n    movementSensibility: 1.9,\n    doubleTapDelay: 300,\n    bindToBorders: true,\n    zoomStep: 0.5,\n    onLongPress: null,\n    longPressDuration: 700,\n    captureEvent: false,\n}; */\n\nconst styles = StyleSheet.create({\n    wrapper: {\n        flex: 1,\n        width: '100%',\n        justifyContent: 'center',\n    },\n    container: {\n        flex: 1,\n        justifyContent: 'center',\n        alignItems: 'center',\n        position: 'relative',\n    },\n});\n\nexport default ReactNativeZoomableView;\n","import { ReactNativeZoomableViewState, ReactNativeZoomableViewWithGesturesProps } from '@dudigital/react-native-zoomable-view';\nimport React from 'react';\nimport ReactNativeZoomableView from './ReactNativeZoomableView';\n\nexport const swipeDirections = {\n  SWIPE_UP: 'SWIPE_UP',\n  SWIPE_DOWN: 'SWIPE_DOWN',\n  SWIPE_LEFT: 'SWIPE_LEFT',\n  SWIPE_RIGHT: 'SWIPE_RIGHT',\n};\n\nclass ReactNativeZoomableViewWithGestures extends React.Component<ReactNativeZoomableViewWithGesturesProps, ReactNativeZoomableViewState> {\n  _onShiftingEnd = (e, gestureState, zoomableViewState) => {\n    if (this.props.onShiftingEnd) {\n      this.props.onShiftingEnd(e, gestureState, zoomableViewState);\n    }\n\n    if (!this._couldCallSwipeEvent(zoomableViewState)) {\n      return;\n    }\n\n    const swipeDirection = this._getSwipeDirection(gestureState);\n    this._triggerSwipeHandlers(swipeDirection, gestureState);\n  };\n\n  /**\n   * Checks if current config options make it possible to process a swipe or if is not necessary\n   *\n   * @returns {*}\n   * @private\n   */\n  _couldCallSwipeEvent(zoomableViewState) {\n    const { onSwipe, onSwipeUp, onSwipeDown, onSwipeLeft, onSwipeRight, swipeMaxZoom, swipeMinZoom } = this.props;\n\n    if (swipeMaxZoom && zoomableViewState.zoomLevel > swipeMaxZoom) {\n      return false;\n    }\n\n    if (swipeMinZoom && zoomableViewState.zoomLevel < swipeMinZoom) {\n      return false;\n    }\n\n    return onSwipe && onSwipeUp && onSwipeDown && onSwipeLeft && onSwipeRight;\n  }\n\n  /**\n   * Checks the swipe and validates whether we should process it or not\n   *\n   * @param gestureState\n   * @returns {*|boolean}\n   *\n   * @private\n   */\n  _validateSwipe(gestureState) {\n    const { onSwipeUp, onSwipeDown, onSwipeLeft, onSwipeRight } = this.props;\n    const swipeDirection = this._getSwipeDirection(gestureState);\n    const { SWIPE_LEFT, SWIPE_RIGHT, SWIPE_UP, SWIPE_DOWN } = swipeDirections;\n\n    return (\n      (onSwipeUp && swipeDirection === SWIPE_UP) ||\n      (onSwipeDown && swipeDirection === SWIPE_DOWN) ||\n      (onSwipeLeft && swipeDirection === SWIPE_LEFT) ||\n      (onSwipeRight && swipeDirection === SWIPE_RIGHT)\n    );\n  }\n\n  /**\n   * Triggers the correct directional callback\n   *\n   * @param swipeDirection\n   * @param gestureState\n   * @private\n   */\n  _triggerSwipeHandlers(swipeDirection, gestureState) {\n    const { onSwipe, onSwipeUp, onSwipeDown, onSwipeLeft, onSwipeRight } = this.props;\n    const { SWIPE_LEFT, SWIPE_RIGHT, SWIPE_UP, SWIPE_DOWN } = swipeDirections;\n\n    // trigger the general onswipe callback\n    if (onSwipe) {\n      onSwipe(swipeDirection, gestureState);\n    }\n\n    // trigger the direction specific swipe callback\n    switch (swipeDirection) {\n      case SWIPE_LEFT:\n        onSwipeLeft && onSwipeLeft(gestureState);\n        break;\n      case SWIPE_RIGHT:\n        onSwipeRight && onSwipeRight(gestureState);\n        break;\n      case SWIPE_UP:\n        onSwipeUp && onSwipeUp(gestureState);\n        break;\n      case SWIPE_DOWN:\n        onSwipeDown && onSwipeDown(gestureState);\n        break;\n    }\n  }\n\n  /**\n   * Calculates what direction the user swiped\n   *\n   * @param gestureState\n   * @returns {*}\n   * @private\n   */\n  _getSwipeDirection(gestureState) {\n    const { swipeLengthThreshold } = this.props;\n    const { SWIPE_LEFT, SWIPE_RIGHT, SWIPE_UP, SWIPE_DOWN } = swipeDirections;\n    const { dx, dy } = gestureState;\n\n    if (!swipeLengthThreshold) {\n      return;\n    }\n\n    if (this._isValidHorizontalSwipe(gestureState)) {\n      if (Math.abs(dx) > swipeLengthThreshold) {\n        return dx > 0 ? SWIPE_RIGHT : SWIPE_LEFT;\n      }\n    } else if (this._isValidVerticalSwipe(gestureState)) {\n      if (Math.abs(dy) > swipeLengthThreshold) {\n        return dy > 0 ? SWIPE_DOWN : SWIPE_UP;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Checks, whether the swipe was done in a horizontal fashion, respecting swipeVelocityThreshold limits\n   *\n   * @param gestureState\n   * @returns {*}\n   *\n   * @private\n   */\n  _isValidHorizontalSwipe(gestureState) {\n    const { vx, dy } = gestureState;\n    const { swipeVelocityThreshold, swipeDirectionalThreshold } = this.props;\n    return this._isValidSwipe(vx, swipeVelocityThreshold, dy, swipeDirectionalThreshold);\n  }\n\n  /**\n   * Checks, whether the swipe was done in a vertical fashion, respecting swipeVelocityThreshold limits\n   *\n   * @param gestureState\n   * @returns {*}\n   *\n   * @private\n   */\n  _isValidVerticalSwipe(gestureState) {\n    const { vy, dx } = gestureState;\n    const { swipeVelocityThreshold, swipeDirectionalThreshold } = this.props;\n    return this._isValidSwipe(vy, swipeVelocityThreshold, dx, swipeDirectionalThreshold);\n  }\n\n  /**\n   * Checks the sipw against velocity and directional offset to make sure it only gets activated, when we actually need it\n   *\n   * @param velocity\n   * @param swipeVelocityThreshold\n   * @param directionalOffset\n   * @param swipeDirectionalThreshold\n   *\n   * @returns {boolean}\n   *\n   * @private\n   */\n  _isValidSwipe(velocity, swipeVelocityThreshold, directionalOffset, swipeDirectionalThreshold) {\n    return Math.abs(velocity) > swipeVelocityThreshold && Math.abs(directionalOffset) < swipeDirectionalThreshold;\n  }\n\n  render() {\n    return <ReactNativeZoomableView {...this.props} onShiftingEnd={this._onShiftingEnd} />;\n  }\n}\n/* \nTODO: Remove this when typescript is proven to work\nReactNativeZoomableViewWithGestures.propTypes = {\n  swipeLengthThreshold: PropTypes.number,\n  swipeVelocityThreshold: PropTypes.number,\n  swipeDirectionalThreshold: PropTypes.number,\n  swipeMinZoom: PropTypes.number,\n  swipeMaxZoom: PropTypes.number,\n  swipeDisabled: PropTypes.bool,\n  onSwipe: PropTypes.func,\n  onSwipeUp: PropTypes.func,\n  onSwipeDown: PropTypes.func,\n  onSwipeLeft: PropTypes.func,\n  onSwipeRight: PropTypes.func,\n};\n\nReactNativeZoomableViewWithGestures.defaultProps = {\n  swipeLengthThreshold: 0,\n  swipeVelocityThreshold: 0.1,\n  swipeDirectionalThreshold: 120,\n  swipeMinZoom: null,\n  swipeMaxZoom: null,\n  swipeDisabled: false,\n  onSwipe: null,\n  onSwipeUp: null,\n  onSwipeDown: null,\n  onSwipeLeft: null,\n  onSwipeRight: null,\n};\n */\nexport default ReactNativeZoomableViewWithGestures;\n"],"names":["PanResponder","React","View","Component","StyleSheet"],"mappings":"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"}